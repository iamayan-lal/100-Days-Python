#MORE ABOUT FUNCTIONS
#Functions are blocks of code that can be called multiple times from different parts of a program.
# def greet():
#     print("Hello, World!")
#     print("Welcome to Python programming!")
#     print("I hope you enjoy our program.")
# greet()

#Functions with Inputs
def greet_with_name(name):
    print(f"hello {name}")
greet_with_name("Ayan")

#Coding Exercise #Life in weeks
def life_in_weeks(current_age):
    time_left = (90 - int(current_age))*52
    print(f"You have {time_left} weeks left.")
life_in_weeks(56)

def greet_with(name,location):
    print(f"Hello {name} from {location}")
    print(f"What is it like in {location}")
greet_with("Ayan","Delhi")

#Coding Exercise:Love Calculator with Functions
def calculate_love_score(name1, name2):
    combined_name = (name1 + name2).lower()
    t = combined_name.count("t")
    r = combined_name.count("r")
    u = combined_name.count("u")
    e = combined_name.count("e")
    l = combined_name.count("l")
    o = combined_name.count("o")
    v = combined_name.count("v")
    e = combined_name.count("e")
    true = int(t) + int(r) + int(u) + int(e)
    love = int(l) + int(o) + int(v) + int(e)
    love_score = str(true) + str(love)
    print(love_score)
calculate_love_score(name1="Kanye West", name2="Kim Kardashian")

#Caesar Cipher Program
alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
direction = input("Type encode to encrypt, decode to decrypt: \n").lower()
text = input("Type your text: \n").lower()
shift = int(input("Type the shift numbert: \n"))

def encrypt(original_text, shift_amount):
    cipher_text = ""
    for letter in original_text:
        shifted_position = alphabet.index(letter) + shift_amount
        shifted_position %= len(alphabet) #0-25
        cipher_text += alphabet[shifted_position]
    print(f"Here is the encoded result: {cipher_text}".)
encrypt(original_text = text, shift_amount = shift)

def decrypt(cipher_text, shift_amount):
    original_text = ""
    for letter in cipher_text:
        shifted_position = alphabet.index(letter) - shift_amount
        shifted_position %= len(alphabet)
        original_text += alphabet[shifted_position]
    print(f"Here is the decoded result: {original_text}".)
decrypt(cipher_text = text, shift_amount = shift)

def cesar(original_text, shift_amount, encode_or_decode):
    output_text = ""
    if encode_or_decode == "decode":
        shift_amount *= -1
    for letter in original_text:
        if letter not in alphabet:
            output_text += letter
        else:
            shifted_position = alphabet.index(letter) + shift_amount
            shifted_position %= len(alphabet)  # 0-25
            output_text += alphabet[shifted_position]
        print(f"Here is the {direction}d result: {output_text}".)
cesar(original_text = text, shift_amount = shift, encode_or_decode = direction)

